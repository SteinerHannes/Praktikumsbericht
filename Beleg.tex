\newcommand{\cmmnt}[1]{}
% Bei Abgabe löschen
\documentclass[nomenclature, 150]{HSMW-Thesis}

\Art{Praktikumsbericht}

\Anrede{Herr}
\Vorname{Hannes}
\Nachname{Steiner}

\Thema{Entwicklung einer Dokumenten-Scanner-App}
\Unterthema{Digitalisierung der Verwaltung an der Hochschule Mittweida}

\Studiengang{Softwareentwicklung}
\Seminargruppe{IF17wS-B \\[\bigskipamount] Matrikelnummer:\\ 46540}
\Fakultaet{\MNI}
\Erstpruefer{Prof\@. Dr\@. Mark Ritter}
\Zweitpruefer{}

\Datum{13.03.2020}

\Tag{13}
\Monat{März}
\Jahr{2020}

\Anlagen{}
\Copyright{Dieses Werk ist urheberrechtlich geschützt.}
\Textsatz{}
\Druck{}
\Verlag{}
\ISBN{}


\begin{document}

\begin{Referat}
% Referat
In dem vorliegendem Praktikumsbericht...

\end{Referat}

%\begin{Vorwort}
%% Vorwort
%\end{Vorwort}

\Hauptteil
% Diese Anweisung nicht loeschen!

%%%%%%%%%%%%%%% - EINLEITUNG - %%%%%%%%%%%%%%%

\chapter{Einleitung}
	Digitalisierung wird gängig als Integration von digitaler Technologie in den Alltag verstanden, und soll helfen Zeit einzusparen \cite{digital}. Mit diesem Gedanken initiierten die Mitarbeiter Holger Langner und Falk Schmidsberger der Hochschule Mittweida, das Projekt \textit{Memo Space}. Im Zuge dessen sollen kleinere Forschungsergebnisse entstehen, die richtungsweisend für die Digitalisierung der Verwaltung von Lehr- und Forschungseinrichtung sind.

	Eine der ersten Ideen\cmmnt{im Zusammenhang mit Memo Space} ist es, die Arbeit von Klausur-Prüfern zu erleichtern. Diese müssen, nachdem die Klausuren kontrolliert wurden, die Zensur, sowie die Eckdaten der Studenten, in ein digitales Format bringen. Grund dafür ist, dass die Noten in das Notensystem der Einrichtung eingetragen werden müssen. 

	Im Rahmen eines zwölfwöchigem Forschungspraktikums an der Hochschule Mittweida arbeiteten der Student Tobias Kallauke und der Verfasser, gemeinsam an einer Lösung zur Digitalisierung dieses Arbeitsschrittes. 
	
	
	... Beide arbeiteten zum einem Teil zusammen und auch getrennt an Aufgaben... Sie entwickelten... (Klausuren-Vorlage, App, Server, OCR? evtl.) / Dabei entstanden .../ Der Verfasser programmierte...
	
	Was noch? 

%%%%%%%%%%%%%%% - HSMW - %%%%%%%%%%%%%%%

\chapter{Hochschule Mittweida}
	Die Hochschule Mittweida - university of applied sience (HSMW) \nomenclature{HSMW}{Hochschule Mittweida - university of applied sience} ist ...
	
	- was gibt es da
	
	- wer leitet die hochschule
	
	- was machen meine betreuer in der hochschule
	
	- aktuelles?
	
\chapter{Grundlagen}
	
	In diesem Kapitel werden wichtige Grundlagen vermittelt...
	
	\section{Model-View-ViewModel}
		Das Entwurfsmuster Model View ViewModel (MVVM)\nomenclature{MVVM}{Model View ViewModel} entstand bei \textit{Microsoft} im Jahr 2005 mit der \textit{Windows Presentation Foundation} (WPF) und \textit{Silverlight-Technologien}. MVVM verwendet das Konzept eines Schichtmodells und ist eine abstrakte Darstellung einer Benutzeroberfläche, in Form einer Klasse, wie man sie unter objektorientierten Programmiersprachen kennt. Diese Klasse enthält Daten, die auf der Benutzeroberfläche angezeigt werden sollen und Anweisungen, die auf der Benutzeroberfläche aufgerufen werden können. Dieses sogenannte ViewModel, weiß nichts von Views, wie es sonst bei anderen Entwurfsmustern üblich ist, um Daten auf der Benutzeroberfläche anzuzeigen. Stattdessen verwendet eine MVVM-View eine Bindungsfunktion (data binging) zur bidirektionalen Zuordnung von Daten aus dem ViewModel zu den jeweiligen Eigenschaften auf der View. Z. B. Einträge in einer Dropdown-Menü. Aber auch das binden von Daten aus dem Model zu Benutzereingaben durch Maus, Tastatur oder Touch-Screens ist möglich. Beispielsweise kann ein Mausklick eine Anweisung in dem ViewModel auslösen. Diese verändert einen Wert im Model, wodurch die View durch data binding aktualisiert wird. 

	\section{Redux.js}
		... Dieser Container besteht aus verschiedenen States. Diese sind dazu da einer View oder mehrere zusammenhängende Views die benötigten Daten bereit zustellen. Die Daten können allerdings nur ge
		- https://github.com/reduxjs/redux
		- https://redux.js.org/introduction/core-concepts
		- https://redux.js.org/introduction/three-principles
	
	- MVVM
	
	- data binding
	
	- redux state container, actions, unidirectional data flow
	
	- publisher und subsciber 
	

%%%%%%%%%%%%%%% - PROBLEMSTELLUNG - %%%%%%%%%%%%%%%

\chapter{Problemstellung} 
	Hochschulmitarbeiter sitzen zum Ende eines Semesters über Tage an der Kontrolle von Klausuren. Diese Aufgabe muss stets mit hoher Konzentration erledigt werden, und lässt sich aber in den meisten Fällen nur schwer durch Maschinen ersetzen. Unter keinen Umständen dürfen bei der Bewertung Fehler vorkommen, was jedoch bei der kognitiven Last der Prüfer immer wieder passiert. Auch nach der Durchsicht der Prüfungsaufgaben ist eine hohe Achtsamkeit wichtig. Denn anschließend wird die Benotung in eine digitale Tabelle überführt. In diese muss die Matrikelnummer, der Vor- und Nachname, sowie die Note des Studenten eingetragen werden. Hier kommt es vor allem bei der Matrikelnummer und der Zensur auf die Richtigkeit jedes Zeichens drauf an. 
	
	\section{Digitalisieren der Klausur-Daten}
	Für genau diesen Vorgang des Digitalisierens wird eine Lösung gesucht. Die Prüfer sollen so bequem und möglichst zeitsparend diese Aufgabe verrichten, ohne dabei ihre Aufmerksamkeitsspanne zu überlasten. Des Weiteren müssen die Ergebnisse der Prüfungen, sowie die Eckdaten der Studenten in ein geeignetes digitales Format gebracht werden, um es der Notenfreigabe weiterzuleiten. Darüber hinaus empfiehlt es sich, digitale Kopien der Klausuren abzuspeichern, da/um ... (warum genau, sollen die gespeichert werden? meine/unsere Idee Online Klausureneinsicht -> ins Fazit/Ausblick (hat viele ''Probleme'' ))
	
	\section{Klausuren-Vorlage}
	Eine Klausuren-Vorlage bzw.\nomenclature{bzw.}{beziehungsweise} ein Gestaltungsleitfaden für Klausuren der Fakultät \textit{Angewandte Computer- und Biowissenschaften} (Fakultät CB)\nomenclature{Fakultät CB}{Fakultät für angewandte Computer- und Biowissenschaften} bietet außerdem die Möglichkeit der Kontrolle des Prüfers an. Genauer ist es durch das vorgegebene Layout der Klausur möglich, einen Teil der Arbeit des Prüfenden auf Fehler zu untersuchen. Auf dem Deckblatt der Klausur ist eine Tabelle, mit drei Zeilen und für jede Aufgabe eine Spalte. In der ersten Zeile befinden sich die Nummern der Aufgaben. In der zweiten, die zu erreichenden Punkte der Aufgabe. Und in der dritten Zeile trägt der Prüfer die erbrachten Punkte des Studenten ein. Unter der Tabelle befindet sich ein Feld für die erreichte Gesamtpunktzahl, sowie ein Feld für die aus den Punkten resultierende Note. Die Punkte pro Aufgabe, die Gesamtpunktzahl und die Zensur stehen in (Korrelation?) Relation zu einander, sodass aus den Punkten der Aufgaben die beiden anderen Felder errechnet werden und mit den Ergebnissen des Prüfers abgeglichen werden könnten. Eine weiteres Merkmal der Klausuren-Vorlage ist ein Feld, für die vom Studenten erreichten Punkte über jeder Aufgabenstellung. Die dortige Angabe sollte mit der, in der Tabelle auf dem Deckblatt übereinstimmen und bietet somit noch eine weitere Möglichkeit der Kontrolle an.
	
	\section{Vorlage verbessern}
	
	
	Templates entwerfen, die optimiert für die Digitalisierungs-Prozesse sind ... 
	
	\section{Weitere Anmerkungen}
	TODO:
	
	Ferner soll bei der Lösung von der Anschaffung neuer Technologie und Geräte abgesehen werden. Grund dafür sind neben den Anschaffungskosten, die Idee, dass das Ergebnis des Forschungsprojekts in weiteren Lehr- und Forschungseinrichtung Anwendung finden sollte.
			
	Was noch?


%%%%%%%%%%%%%%% - ANFORDERUNGEN - %%%%%%%%%%%%%%%

\chapter{Anforderungen}
	Es soll eine iOS-App entstehen mit der Klausuren digitalisiert werden können. Genauer müssen die, für die Notenfreigabe relevanten Daten der Klausur, in ein tabellarisches Format gebracht werden. Um unterschiedliche Klausuren oder auch andere Dokumente zu unterstützen, soll das Anlegen von Scan-Vorlagen in der App möglich sein. Hierfür (aber auch zum Einscannen) benötigt die App die Berechtigung für das Kamera-System. Diese muss, bei der ersten Benutzung einmalig erteilt werden.
	
	Die Scan-Vorlagen bestehen aus zwei Komponenten. Die eine sind zugeschnittene Fotos der Seiten eines Dokuments. Und die zweite sind die Regionen auf den Bildern, wo sich die zu digitalisierenden Informationen befinden. Dem Benutzer muss es möglich sein, zuerst die Fotos zu machen und anschließend Regionen auf den Seiten zu markieren. Weiter benötigen die Regionen Namen bzw. Typen, die der Benutzer angeben muss. Die Angabe des Typs ist wichtig, da dadurch eindeutig wird, ob es sich um die Note oder die Matrikelnummer des Studenten handelt. Diese Eindeutigkeit wird nicht nur für die automatische Erstellung der Tabelle benötigt, sondern auch für die Texterkennung. 
	
	Optical character recognition (OCR)\nomenclature{OCR}{optical character recognition, deutsch: optische Zeichen Erkennung und im deutschen Synonym für Texterkennung}, auf deutsch optische Zeichen Erkennung, soll dazu benutzt werden, die Informationen der Regionen zu digitalisieren. Um die Texterkennung zu verbessern, soll der Typ der Regionen verwendet werden. Damit könne dem OCR mögliche Ergebnisse mitgeteilt oder die Ergebnisse angepasst werden. Beispielsweise bestehen Zensuren immer aus Dezimalzahlen von 1 bis 6 und mit nur einer Nachkommastelle. Wird der Buchstabe O anstelle der Ziffer 0 erkannt, kann so der Fehler korrigiert werden.
	
	Zudem muss die Texterkennung auf dem Gerät selbst statt finden. Allerdings darf die App auch Texterkennung auf externen Servern unterstützen. Hierfür müssen dann die entsprechenden API-Schnittstellen implementiert oder für einen eigenen Server entwickelt werden.

	Die digitalisierten Daten, die für die Texterkennung entstandenen Dokumenten-Bilder und die erstellten Scan-Vorlagen, soll außerhalb der App auf einem Server gespeichert werden. Somit ist die Möglichkeit gegeben, die Vorlagen wieder zu verwenden und anderen Benutzern der App zur Verfügung zu stellen. Des Weiteren hat diese zentralen Stelle den Vorteil alle anfallenden Daten zu verwalten, was die Benutzung der App trotz vieler Benutzer vereinfacht.
	
	Damit Synchronität der Daten auf den Geräten und dem Server gewährleistet werden kann, benötig die App hierfür ebenfalls Schnittstellen. Diese sollten den standardmäßigen \textit{CRUD}\nomenclature{CRUD}{Das Akronym CRUD steht für Create/Erstellen, Read/Lesen, Update/Aktualisieren und Delete/Löschen und umfasst die vier grundlegenden Operationen persistenter Speicher}-Operationen entsprechen. 
	
	Da die gesamte Kommunikation über das Internet geschieht, muss das Softwaresystem die üblichen Datenschutz- und Datensicherheit-Richtlinien entsprechen, bzw. implementieren.
	

%%%%%%%%%%%%%%% - GRUND IDEE ZUM LÖSEN DES PROBLEMS - %%%%%%%%%%%%%%%

\chapter{Konzept der Dokumenten-Scanner-App}
	Wie in der Problemstellung und Anforderung beschreiben, soll die Dokumenten-Scanner App wichtigen Daten auf dem Deckblatt einer Klausur, wie Vor- und Nachname des Studenten, seine Matrikelnummer sowie die Note erkennen, digitalisieren und in ein für die Notenfreigabe geeignetes Format bringen. Die digitalisierten Daten sollen anschließend an einen Server gesendet werde, wo sie und die beim Einscannen entstandenen Bilder gespeichert werden. Verwendet eine einzuscannende Klausur die Klausuren-Vorlage der Fakultät CB oder ähnliche, die eine Punkteübersicht haben, dann soll es außerdem möglich sein, die Punkte sowie die Note auf Richtigkeit zu überprüfen. 

	Zur Digitalisierung und Kontrolle der Daten werden Scan-Vorlagen verwendet. Diese muss vor dem Einscannen der ausgefüllten Klausuren erstellt werden, um zu gewährleisten, dass die richtigen Daten digitalisiert werden. Beim Erstellen einer Scan-Vorlage geht man wie folgt vor:
	\begin{itemize}
		\item Zuerst wird jede Seite der Klausur fotografiert. Dabei wird in jedem Bild das Dokument erkannt, vom Hintergrund getrennt oder genauer gesagt ausgeschnitten und perfekt ausgerichtet. Zudem wird der Kontrast erhöht, so dass die Schrift leichter lesbarer wird.
		\item Anschließend markiert man diejenigen Regionen auf jeder Seite, die zu digitalisieren und/oder kontrollieren sind. Zusätzlich muss jeder Region ein Name und einer der folgenden Typen zugeordnet werden: Unbekannt, Name, Matrikelnummer, Seminargruppe, Punkte und Note. Mithilfe des Typs wird die Texterkennung verbessert und falsche Ergebnisse automatisch korrigiert. Dazu später mehr.
		\item Des Weiteren kann man aus allen markierten Regionen diese auswählen, die in Relation stehen. Diesen Relationen werden danach noch weitere Eigenschaften zugeteilt, um sie später bei der Kontrolle richtig zu analysieren. So eine Eigenschaft könnte sein, dass es sich um einen Vergleich zwischen zwei in Relation stehenden Regionen handelt. Z. B. ist die eine Region die Zelle in der Punkteübersichts-Tabelle, in der die erreichten Punkte zu Aufgabe 1 rein geschrieben werden sollen. Und die zweite Region die Stelle über der Aufgabenstellung von Aufgabe 1, in der ebenfalls die erreichten Punkte eingetragen werden sollen. Weitere Beispiele für solche Relationen und Eigenschaften sind die Summanden für die erreichte Gesamtpunktzahl und die Summe selbst, oder auch noch die daraus resultierende Note.
		\item Als letztes speichert man die Vorlage ab, welche dann automatisch an einen Server gesendet wird, so dass andere diese Vorlage ebenfalls nutzen können.
	\end{itemize}
	
	Nach der Erstellung einer Vorlage kann das Dokument digitalisiert werden. Dazu scannt man die Seiten in derselben Reihenfolge, wie in der Scan-Vorlage ein. Die App digitalisiert mithilfe von OCR den Inhalt, in den vordefinierten Regionen. Der Typ der Region nimmt nun Einfluss auf das Ergebnis. Durch ihn wird während der Worterkennungsphase eine Liste an vordefinierten Ergebnissen eingespeist. Diese Liste hat Vorrang vor dem Standard-Lexikon, welches verwendet wird. Ein Beispiel für solch eine Liste könnten, wie in den Anforderungen beschrieben, alle möglichen Noten sein. Auch vorstellbar ist, dass alle Seminargruppen oder Namen von Personen, die an der Klausur teilgenommen haben, dort verwendet werden. 
	
	Weiter wäre eine zusätzliche Möglichkeit der Korrektur erdenklich. Angenommen, jemand verschreibt sich bei seiner Seminargruppe und vergisst ein Zeichen. Die Texterkennung erkennt zwar jedes Zeichen richtig, jedoch wäre es für die Notenfreigabe eine nicht korrekte Seminargruppe. Deshalb könnte man auch im Nachhinein das Ergebnis mit einer Seminargruppe ersetzt, die die größte Übereinstimmung mit dem erkannten Wort hat. Dieses Vorgehen kann man dadurch verbessern, wenn man dafür nur die Seminargruppen-Bezeichnungen verwendet, die auch tatsächlich die Klausur geschrieben haben. Ähnliches gilt auch für die Namen oder Matrikelnummern der Studenten.
	
	Um wirklich sicher zu gehen, ist es aber im Anschluss an die Texterkennung möglich die Resultate noch einmal zu überprüfen und zu korrigieren, bevor es an den Server zum Abspeichern gesendet wird. Dazu wird außerdem die confidence des OCR bei jeder Region angezeigt. Diese sagt aus, wie sicher sich die Texterkennung ist, das das Ergebnis stimmt. Jedoch kann es auch hier falsche Positiv-Ergebnisse geben, weshalb auch das kein perfekter Indikator für die Richtigkeit ist.
	
	Ein wichtiger Vorteil einer App gegenüber anderen Lösungen ist, dass so gut wie jeder Mitarbeiter an einer Lehr- und Forschungseinrichtung ein eigenes oder Zugang zu einem Smartphone oder Tablet hat.

		... noch mehr? (Auf Tobias warten...)
	
	- Noch mehr zu OCR sagen: was es ist, wie es geht, komplett eigenes Kapitel?


%%%%%%%%%%%%%%% - PROTOTYP - %%%%%%%%%%%%%%%
	
\chapter{Entwicklung des ersten Prototyps}
	Vor Beginn des Praktikums saßen die Praktikum-Betreuer Falk Schmidsberger, Robert Manthey der Hochschule Mittweida, mit Tobias Kallauke und mir zusammen. Wir diskutierten, welches Thema für das Praktikum geeignet ist, wie eine Art Durchführbarkeits- / Machbarkeitsstudie und entschieden uns für den Dokumenten-Scanner. Da ich privat Erfahrung in \textit{Swift} sowie \textit{iOS}-Entwicklung gesammelt habe, sollte ich damit anfangen den Scanner als \textit{iOS}-App zu entwickeln. Wir machten uns auch direkt noch Gedanken über die Anforderungen an die App und definierten, wie das zukünftige Software-System mit Server und Backend aussehen könnte.

	\section{Planung und Vorbereitung}
		In der aller ersten Woche habe ich mich hauptsächlich mit der Problemstellung auseinander gesetzt, Ideen entwickelt, Problemanalyse betrieben und einen kleinen Prototypen entwickelt. Ich begann damit die Dokumentation von \textit{Vision}, \textit{VisionKit} und \textit{PhotoKit} von \textit{Apple} an zu schauen. Danach hatte ich einen guten Überblick darüber, was ich noch zu entwickeln habe und was mir Frameworks abnehmen können. Zum einen war das Erkennen und gerade ziehen von Dokumenten in Echtzeit in der Kamera, sowie die Texterkennung auf Bildern schon in den Frameworks implementiert. Nebenbei entdeckte ich eine Beispiel-App von \textit{Apple} \cite{visionBasicApp}, in der es um Erkennen von Objekten in Standbildern ging. Diese schaute ich mir an, um das Vision Framework genauer zu verstehen, sodass ich mich gut eingearbeitet habe.
		
		Bei meiner Recherche stellte ich fest, dass die App nur Geräte mit iOS 13.0 oder neuer unterstützen werden kann. Grund dafür sind die \textit{Apple} Frameworks \textit{SwiftUI} und \textit{VisionKit}. \textit{SwiftUI} bietet die Möglichkeit, Benutzeroberflächen für alle \textit{Apple}-Plattformen in \textit{Swift} zu erstellen. Die deklarative \textit{Swift}-Syntax ist für mich einfach zu lesen und schnell zu schreiben, so dass es möglich ist, die App in wenigen Wochen für iPhone und iPad zu schreiben. Als Alternative gibt es noch \textit{UIKit} oder auch \textit{AppKit}, die unter alle iOS Versionen funktioniere. Diese Frameworks sind allerdings nicht deklarativ sodass, Views sowohl im Code als auch in Interface-Dateien getrennt voneinander erstellt und konfiguriert werden müssen \cite{heise2019einsitegInSwiftUI}. Dadurch dauert die Entwicklung einer App, im Gegensatz zu SwiftUI deutlich länger.  \textit{VisionKit} dagegen, ist das Framework zum Scannen der Dokumente. Auch hierfür gibt es eine Alternative. Das Framework ist von den Entwicklern von \textit{WeTransfer} und funktioniert auch auf älteren iOS Versionen. Allerdings unterstützt \textit{WeScan} noch kein stapelweises Scannen. Das bedeutet man kann immer nur ein Foto machen, welches erst abgespeichert werden muss, bevor man das nächste machen kann. Das ist für den Benutzer nicht bequem und spart wahrscheinlich auch keine Zeit.
		
		- Link zu weScan und den andern Frameworks?
		- Video-Link noch mit rein. (https://www.youtube.com/watch?v=qk2y-TiLDZo) zur Verdeutlichung
		
		Um das Projekt gut durch zu planen benutze ich \textit{Scrum} als Projektmanagement. Dies ist für agile Softwareentwicklung gut geeignet. Durch die gesammelte Erfahrung mit Scrum aus den vorherigen Semester, fiel mir die Planung leicht. Mit GitHub Projects und Issues konnte ich so dem Sprint Aufgaben zuordnen und Fortschritt nachvollziehen. 
		
	\section{Entwurf und Design}
		Nach der Vorbereitung begann ich damit, mir Gedanken zu dem Workflow der App zu machen und erstellte den ersten Sprint bis zum nächsten Meeting. Für den Workflow fertigte ich zu jeder View ein grobes Design an, welches sehr schnell in \textit{SwiftUI} umzusetzen ist. Das Aussehen der App sollten sich dann im Laufe der Zeit noch ändern, jedoch stand erstmal die Umsetzung des Konzepts im Vordergrund. 
		
		Aus den Designs und dem Workflow heraus entwickelte ich einen groben Plan, wie die Daten in der App gehandhabt werden sollten. Jedoch stellte ich schnell fest, dass meine Idee des Datenflusses nicht ideal ist, wenn noch mehr Views hinzukommen. Außerdem stellte die Kommunikation mit dem Server ein Problem dar, da diese immer asynchron abläuft. Aus diesen Gründen suchte ich nach einer Lösung. Bei der Suche entdeckte ich \textit{Redux.js} eine JavaScript-Bibliothek zur Verwaltung von Zustandsinformationen in Webanwendung. ...
		
		Da \textit{SwiftUI} das Entwurfsmuster MVVM umsetzt, ist es möglich einen \textit{Redux.js} ähnlichen State Container, als ViewModel zu implementieren. Und weil die App an einen Server gekoppelt sind und durch die Synchronisation mit diesem viele 
		
		
	\section{Implementierung}
		
		Einzelne Schritte als eigene Section mit Verlauf der jeweiligen Entwicklung: erst das, dann kam das, dann musste es so, ...
			
		\subsection{Template erstellen}
		
		\subsection{Template speichern}
		
		\subsection{Template verwenden}
		
		...
		
		Die Beispiel-App von \textit{Apple} nahm ich mir als Vorbild für die Umsetzung der Texterkennung.
		
		...
		
	\section{''Abnahme''}	
		Abnahme ... \\ \\ \\
	
	
	Weitere Punkte die in Kapitel 6 rein könnten/sollten: 
	
	- beschreiben wie die einzelnen Views/Seiten nun aussehen und funktionieren? oder eher den Prozess der Entwicklung?
	
	- Bild mit Wireframe aller Views und deren Workflow?
	
	- AppState erklären? (Single source of truth) -> später AppStore mit mehreren States
	
	- erklären deskew / Dokument ausrichten?
	
	- Umrechnung der Bilder vom Template aus und zuschneiden der neuen Regionen erklären
	
	- Attribute hinzufügen (den Vorgang) -> Rechteck einzeichnen...
	
	- Verwendete Programme, Sprache, etc. 
	
	- ein paar Worte, wie gut die Entwicklung lief (Simulator vs. echtes Gerät), wo sind die Grenzen des Simulators (Keine Kamera), wo waren Probleme mit dem echten Gerät...
	


%%%%%%%%%%%%%%% - WEITERENTWICKLUNG - %%%%%%%%%%%%%%%

\chapter{Weitere Entwicklung und Besonderheiten}

	\section{App-Architektur}
		- redux like app store mit states erklären? (single source of truth)
	
	\section{API}
		- auf die API eingehen? oder nur tobias?
	
	\section{}
		- 



%%%%%%%%%%%%%%% - GRENZEN - %%%%%%%%%%%%%%%

\chapter{Grenzen der App}
	\section{Probleme beim Erkennen von Dokumenten}
		- Gleich-farbiger Hintergrund
			
		- Wenig Licht
		
		- Hintergrund mit starken Kanten
		
		- Runde Ecken, keine Ecken
		
		- Starke Kanten im Bild (schwarzer Kreditkartenstreifen)
		
		- zu jedem möglichem vlt. dann ein Beispiel Bild
		
	\section{Probleme der Klausur-Vorlage beim Scannen}
		- Schrift zu klein
		
		- zu wenig Platz
		
		- zu viel Platz
		
		- Überschneidungen
		
		- ...
		
	\section{Weitere ...}
		- Abstürze, Memory Leaks, 



%%%%%%%%%%%%%%% - TEMPLATES - %%%%%%%%%%%%%%%

\chapter{Templates}
	- Template und den Entwicklungsprozess vorstellen, 
	
	- wieso weshalb warum muss das nun so aussehen?
	
	- Was kann an der neuen Vorlage immer noch optimiert werden?	
	
	- Welche Probleme konnten behoben werden?
	



%%%%%%%%%%%%%%% - AUSBLICK - %%%%%%%%%%%%%%%
		
\chapter{Ausblick}
	- Es müssen nicht nur Klausuren sein, sondern alles mögliche (Krankenscheine, Urlaubsscheine, was auch immer, nur DB muss angepasst werden. (oder automatisches generieren von DB-Tabellen an Hand der Template Attribute))
	
	- Server mit Bildern als Klausuren-Einsicht nutzen -> allerdings viele Probleme (Klausuren würden kopiert werden -> Profs mehr Arbeit, keinen direkten Kontakt zum Prof wegen Fragen, Verbesserungen oder Anmerkungen, ... )
	
	- QR-Code-Idee um Vorlagen weg zu lassen -> Programm oder Plugin (Word/LaTex) was die QR-Codes dann automatisch erstellt und richtig einfügt. (Wichtige Daten sind da hinterlegt, Vor- und Nachteile von QR-Codes, ...)
	
	- Ist die App nun schneller als der normale Umgang bleibt offen -> Bachelorarbeit knüpft da an...
	

\Anhang

\chapter{Tätigkeitsbericht}
	\begin{longtable}[h!]{ p{4em} | p{356pt} }
		Datum & Tätigkeit \\ \hline
		\endfirsthead
		Datum & Tätigkeit \\ \hline
 		\endhead

 		\hline
 		\endfoot
		
		24.02. - 01.03. & 
			Ich habe mich mit der Problemstellung auseinander gesetzt, Ideen gesammelt, Problemanalyse betrieben und einen kleinen Prototypen entwickelt. Dazu erstellte ich einen minimalen Projektplanung, arbeitete mich in die Frameworks \textit{Vision} und \textit{VisionKit} ein und setzte eine Versionsverwaltung auf. Zusätzlich suchte ich nach einer passenden App-Architektur, die geeignet für das deklarative GUI-Framwwork SwiftUI, sowie für asynchrone Aufgaben, wie z. B. API-Aufrufe ist. Dabei stieß ich auf \textit{Cleancode Architecture} und \textit{Redux}.
				
			Am Ende der Woche konnte man in der App Vorlagen mit einer Seite erstellen. Das heißt man konnte ein Foto machen, aus welchem das Dokument rausgeschnitten und anschließend ausgerichtet wurde. Weiter war es möglich Regionen auf dem Dokument zu markieren und diese in der Vorlage abspeichern. Ansonsten konnten die Vorlage schon dazu benutzt werden, um die Regionen auf dem neuen Foto heraus zu schneiden.
			\\ \hline
		02.03. - 08.03. &
			In dieser Woche habe ich die Texterkennung auf den berechneten Regionen eines neuen Fotos implementiert, den Workflow sowie viele andere Kleingikeiten in der App verbessert und alle Fehler der letzten Woche behoben, sodass ich neue Dinge implementieren konnte. Zudem probierte ich CI sowie Lint für das Projekt aus. Da CI für eine iOS-App mit \textit{GitHub Actions} schwer aufzusetzen war und ab April etwas kosten würde, lies ich es sein. Des Weiteren pflegte ich das Projekt Management durch \textit{Issues} und \textit{Project-Boards} in GitHub. Anschließend programmierte ich den App-Workflow so um, dass nun mehr als eine Seite aufgenommen und analysiert werden konnte. 
				
			Abgesehen von neuem Quellcode fing ich an den Praktikumsbericht zu schreiben und arbeitet mich dafür in \LaTeX \xspace und die Bachelorarbeits-Vorlage für \LaTeX \xspace der Hochschule Mittweida ein.
			\\ \hline
	 	09.03. - 15.03. &
	 		Zu Beginn der dritten Woche schaute ich mir Möglichkeiten für serverseitiges OCR an. Genauer sammelte ich Informationen zu dem Framework Vapor und Swift unter Linux. Jedoch funktionieren die Frameworks \textit{Vision} und \textit{CoreML} von \textit{Apple} unter Linux nicht, weshalb sich IronOCR als beste Option herausstellte. Ich entwickelte ein Datenbankmodell, mithilfe der in der App verwendeten Datentypen und erstellte dazu noch eine JSON-Struktur die später für die APIs verwendet werden könnte. Außerdem gab es ein Meeting, in dem wir unseren aktuellen Stand präsentieren sollten, um weitere Schritte und Aufgaben zu planen.Bis zum Ende der Woche arbeitete ich weiter an meinem Beleg und schrieb den Datenfluss in der App um. Nun ähnelt er sehr dem Redux-Model.
	 		\\ \hline
	 	16.03. - 22.03. & 
	 		Anfangs habe ich weiter an meinem Praktikumsbericht geschrieben, neue Issues hinzugefügt und bearbeitet. Außerdem gepflegte ich die Dokumentation und betrieben Projekt Management, um nun Links zwischen Regionen hinzuzufügen. Dabei entstanden neue Views und der Redux-Store musste dadurch angapsst werden. Es kam eine Erweiterung für die Texterkennung hinzu, so dass man durch die Auswahl eines Datentyps, das Resultat der Erkennung verbessern konnte. Des Weiteren habe ich bis zum Ende der Woche die Vergleich-Links vollständig implementiert und die App auf Fehler und Abstürze kontrolliert, sowie den Beleg um einige Kapitel erweitert.
	 		\\ \hline
	 	23.03. - 30.03. &
	 		...
	 		\\ \hline
	\end{longtable}
		
	
\begin{thebibliography}{99}
	\bibitem{digital}
		% nochmal genauer nachschauen, guten Link finden, und genauen Namen...
		Michael Graf, Partner bei PwC
		\\\texttt{http://www-cs-faculty.stanford.edu/\~{}uno/abcde.html}
		
	\bibitem{visionBasicApp}
		Apple Developer - Sample Code, Detecting Objects in Still Images
		\\\texttt{https://developer.apple.com/documentation/vision/
		detecting\_objects\_in\_still\_images}		
	
	\bibitem{bragge2013model}
		BRAGGE, Matti, et al. Model-View-Controller architectural pattern and its evolution in graphical user interface frameworks. 2013.
		\\\texttt{https://lutpub.lut.fi/handle/10024/92156}
		
	\bibitem{heise2019einsitegInSwiftUI}
		Thomas Sillmann - Einsteig in SwiftUI. 22.11.2019
		\\\texttt{https://www.heise.de/developer/artikel/Einstieg-in-SwiftUI-4594018.html}
	
\end{thebibliography}

\end{document}

%	Gemeinsam mit den Betreuern des Praktikums und Tobias Kallauke entstand eine typische Client-Server-Architektur. Mit Hilfe von verschiedenen Apps, auf der Basis von Android, iOS oder auch im Browser sollen.
	
%	Die Grund Idee des Dokumentenscanner ist es den Vorgang der Klausuren-Kontrolle und deren Noteneintragung zu vereinfachen. Genauer soll es möglich sein die wichtigen Daten auf der ersten Seite einer Klausur, wie Vor- und Nachname des Studeten, seine Matrikelnummer sowie die Note zu erkennen, digitalisieren und in ein geeignetes Format zu bringen, um es anschließend der Notenfreigabe der Hochschule zu übermitteln. 

%	Des Weiteren ist es für die Prüfer der Klausur hilfreich, wenn die Punkte der Klausur kontrolliert bzw. überprüft werden. Konkret bezieht sich die Überprüfung der Punkte auf eine Klausuren-Format-Vorlage, die im Bereich der Fakultät Angwandte Computer- und Biowissenschaften genutzt wird. Diese Vorlage hat auf dem Deckblatt der Klausur zu jeder Aufgabe ein Feld für die erreichten und die zu erreichenden Punkte. Sowie die Summe der erreichten Punkte. Hier könnte der Dokumentenscanner die erreichte Gesamtpunktezahl sowie die daraus resultierende Note überprüfen. Des Weiteren befinden sich auf den nachfolgenden Seite der Klausur über jeder Aufgabe ein Feld für die erreichten und die zu erreichenden Punkte der jeweiligen Aufgabe. Die dort vom Prüfer eingetragenen Punkte könnten ebenfalls mit denen auf dem Deckblatt verglichen werden. 
%
%	Durch die Erweiterung der Grundidee um Scan-Vorlagen wurde es auch möglich Daten anderer Dokumente zu digitalisieren und in ein geeignetes Format zu bringen. Genauer soll es dem Benutzer möglich sein von jedem beliebigen Dokument eine Vorlage zu erstellen, in der er Stellen auf dem Dokument markiert, wo sich die zu digitaliserenden Daten befinden.

